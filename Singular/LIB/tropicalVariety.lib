///////////////////////////////////////////////////////////////////////////////
version="version tropicalNewton.lib 4.0.3.3 Nov_2017 "; // $Id$
category="Tropical Geometry";
info="
LIBRARY:         tropicalNewton.lib  Computations in Tropical Geometry
                                     using Newton Polygon methods

AUTHORS:         Tommy Hofman,       email: thofmann@mathematik.uni.kl.de
                 Yue Ren,            email: reny@cs.bgu.ac.il
                 Dominik Bendle,     email: bendle@rhrk.uni-kl.de

OVERVIEW:
  This libraries contains algorithms for computing
  - non-trivial points on tropical varieties,
  - zero-dimensional tropical varieties,
  - one-codimensional links of tropical varieties
  based on Newton polygon methods.

REFERENCES: Hofmann, Ren: Computing tropical points and tropical links, arXiv:1611.02878
            (WARNING: this library follows the max convention instead
                      and triangular sets follow the definition of the Singular book)

SEE ALSO: tropicalVariety, tropical_lib

KEYWORDS: tropical geometry; tropical varieties; Newton polygons

PROCEDURES:
  setUniformizingParameter()  sets the uniformizingParameter
  val()                       returns valuation of element in ground field
  newtonPolygonNegSlopes()    returns negative of the Newton Polyong slopes
  cccMatrixToPositiveIntvec() helper function to turn a computed valuation vector
                              into a usable weight vector in Singular
  tropicalPointNewton()       computes point on tropical variety
  switchRingsAndComputeInitialIdeal()
                              switches rings and computes initial ideal
  tropicalVarietyNewton()     computes tropical variety of zero-dimensional ideal
  tropicalLinkNewton()        computes tropical variety that is polyhedral fan
                                and has codimension one lineality space
";

///////////////////////////////////////////////////////////////////////////////

proc mod_init()
{
  option(noredefine);
  option(redSB);
  LIB "gfan.lib";
  LIB "triang.lib";
  LIB "linalg.lib";
  LIB "presolve.lib";
  LIB "tropicalNewton.lib";
  LIB "tropicalPuiseux.lib";
  LIB "tropicalProjection.lib";
  LIB "tropical.so";
  newstruct("decoratedGroebnerCone","cone polyhedralCone, bigintmat orbitIdentifier, ring polynomialRing, ideal polynomialIdeal, ideal initialIdeal, number uniformizingParameter");
}

///////////////////////////////////////////////////////////////////////////////

// returns the tropicalization of a monomial f, i.e.,
// if f = c_\alpha*x^\alpha, returns val(c_\alpha)+\alpha*x
static proc tropicalizeMonomial(poly f, number uniformizingParameter)
{
  if (f==0)
  {
    return (0);
  }

  poly ftrop = valuation(leadcoef(f),uniformizingParameter);
  intvec fexp = leadexp(f);
  for (int i=size(fexp); i>0; i--)
  {
    ftrop = ftrop + fexp[i]*var(i);
  }
  return (ftrop);
}

static proc tropicalizeMonomials(ideal F, number uniformizingParameter)
{
  ideal Ftrop;
  for (int i=size(F); i>0; i--)
  {
    Ftrop[i] = tropicalizeMonomial(F[i],uniformizingParameter);
  }
  return (Ftrop);
}

// merges two lists of tropical points with multiplicities
static proc mergeMultisets(list globalWM, list localWM)
{
  matrix globalW = globalWM[1];
  intvec globalM = globalWM[2];
  matrix localW = localWM[1];
  intvec localM = localWM[2];
  int n = ncols(globalW);

  for (int i=nrows(localW); i>0; i--)
  {
    // iterate backwards through all rows of globalW,
    // break if a row is found that is smaller or equal to localW[i]
    for (int j=nrows(globalW); j>0; j--)
    {
      if (localW[i,1..n] >= globalW[j,1..n])
      {
        break;
      }
    }

    if (j==0)
    {
      // localW[i] smaller than all rows of globalW, preprend it
      matrix newGlobalW[nrows(globalW)+1][n];
      newGlobalW[1,1..n] = localW[i,1..n];
      newGlobalW[2..nrows(globalW)+1,1..n] = globalW;
      globalW = newGlobalW;
      globalM = localM[i],globalM;
    }
    else
    {
      if (localW[i,1..n] == globalW[j,1..n])
      {
        // localW[i] occurs in globalW, increment globalM accordingly
        globalM[j] = globalM[j]+localM[i];
      }
      else
      {
        // localW[i] does not occur in globalW, insert it in position j+1
        matrix newGlobalW[nrows(globalW)+1][n];
        newGlobalW[j+1,1..n] = localW[i,1..n];
        intvec newGlobalM;
        newGlobalM[size(globalM)+1] = 0;
        newGlobalM[j+1] = localM[i];

        newGlobalW[1..j,1..n] = globalW[1..j,1..n];
        newGlobalM[1..j] = globalM[1..j];

        if (j<nrows(globalW))
        {
          newGlobalW[j+2..nrows(globalW)+1,1..n] = globalW[j+1..nrows(globalW),1..n];
          newGlobalM[j+2..size(globalM)+1] = globalM[j+1..size(globalM)];
        }
        globalW = newGlobalW;
        globalM = newGlobalM;
      }
    }
  }
  return (list(globalW,globalM));
}
example
{ "EXAMPLE for testing purposes"; echo=2;

  ring r = 0,x,dp;
  matrix globalW[5][3] =
    -1,0,1,
    -1,1,0,
    0,0,0,
    1,-1,0,
    1,0,0;
  intvec globalM = 1,2,3,4,5;

  matrix localW[5][3] =
    -1,-1,-1,
    -1,2,-1,
    0,0,0,
    0,1,1,
    1,0,1;
  intvec localM = 9,8,7,6,5;
  list mergedWM = mergeMultisets(list(globalW,globalM),list(localW,localM));
  print(mergedWM[1]);
  mergedWM[2];
}

proc tropicalVarietyZerodimensional(ideal I, number uniformizingParameter, list #)
"USAGE:  tropicalVarietyZerodimensional(ideal I[, string strat, ...]);
ASSUME:  I is zerodimensional over a field of characteristics 0
NOTE:    possible strategies are
           separation - use projection to seperate the roots (default)
           approximation - use approximation to determin the roots (to come)
RETURN:  list(W,M), where
           W = matrix whose rows are the points in Trop(I)
           M = intvec whose entries are the multiplicities of the points in Trop(I)
EXAMPLE: example tropicalVarietyZerodimensional; shows an example
"
{
  option(redSB);

  // 0: preparation, read off optional parameters
  //      and compute a lexicographical GB.
  string strat = "separation";
  if (size(#)>0)
  {
    strat = #[1];
  }

  def rOrigin = basering;
  int n = nvars(basering);

  execute("ring rLex = ("+charstr(rOrigin)+"),("+varstr(rOrigin)+"),lp;");
  ideal I = fetch(rOrigin,I);
  ideal stdI = stdfglm(I);
  number uniformizingParameter = fetch(rOrigin,uniformizingParameter);

  // 2:  preprocessing.
  // 2.0 compute factorizing triangular decomposition.
  //       the rest will be done for each triangular set individually and
  //       'I' will refer to a triangular factor of the original ideal
  list triangularDecomposition = triangLfak(stdI);

  list triangularDecompositionWM;
  for (int kTriang = size(triangularDecomposition); kTriang>0; kTriang--)
  {
    setring rLex;
    ideal ITriang = triangularDecomposition[kTriang];

    // 2.1 identify x_i with x_i = \lambda or x_i = \lambda*x_j^{d_j}
    //       for some constant \lambda and some power d_j.
    //       the valuation of these variables are uniquely determined.
    list E = elimpart(ITriang);
    // Explanation of elimpart:
    //   What it does: fast heuristic computation to obtain a map \phi: K[x] -> K[u],
    //   where K[x] stands for the basering and u is a subset of x,
    //   together with an ideal Iu in K[u] such that K[x]/I \cong K[u]/Iu.
    //   What it returns:
    //   - E[1] = Iu (type ideal)
    //   - E[2] = v, where v = x \setminus u
    //   - E[3] = kernel(\phi)
    //   - E[4] = maxideal(1), but with all x not in u substituted with 0
    //   - E[5] = \phi(maxideal(1))

    // parse the output of elimpart:
    //   go through E[4] and E[5] and identify all variables which have been (eliminated AND)
    //   substituted by a monomial in u, these for the variables of our simplified ring
    ideal u = E[4];           // might need to add more x to u
    ideal xImage = E[5];      // might need to undo a few substitutions
    for (int i=1; i<=n; i++)
    {
      if (E[4][i] == 0 && size(xImage[i])>1) // if it was eliminated but with no monomial
      {                                      // undo the elimination
        u[i] = var(i);
        xImage[i] = var(i);
      }
    }
    u = simplify(u,2);  // removes all zero entries so that the entries of u are
                        // in bijection with the variables that were not eliminated
    ideal xImageTrop = tropicalizeMonomials(xImage,uniformizingParameter);
    // 3: compute Trop(ISimplified)
    if (size(u)==0)
    {
      // 3.0 very trivial case.
      //       I has one solution which lives over the basefield and was found using elimpart
      //       in this case, xImageTrop is the desired tropicalPoint
      matrix tropicalPoint[1][n] = xImageTrop[1..n];
      triangularDecompositionWM[kTriang] = list(tropicalPoint,intvec(1));
      kTriang--;
      continue; // WARNING: does not decrement kTriang
    }

    // 3.2 general case.
    // 3.2.0  create the simplified ring with the simplified ideal
    execute("ring rSimplified = ("+charstr(rLex)+"),("+string(u)+"),dp");
    map phi = rLex,imap(rLex,xImage);
    ideal ITriangSimplified = groebner(phi(ITriang));
    number uniformizingParameter = fetch(rLex,uniformizingParameter);

    // 3.2.1:  compute tropical variety of simplified ring according to strategy
    list WMSimplified;
    if (nvars(rSimplified)==1)
    {
      if (size(ITriangSimplified)>1 || deg(ITriangSimplified)==0)
      {
        ERROR("tropicalVarietyZerodimensional: bug in reduction to the zero-dimensional case");
      }
      list out = tropicalVarietyUnivariate(ITriangSimplified[1],uniformizingParameter);
      list out1 = out[1];
      matrix WSimplified[size(out1)][1] = out1[1..size(out1)];
      list out2 = out[2];
      intvec MSimplified = out2[1..size(out2)];
      WMSimplified = list(WSimplified,MSimplified);
    }
    if (nvars(rSimplified)>1 && strat == "separation")
    {
      WMSimplified = tropicalVarietyViaProjection(ITriangSimplified,uniformizingParameter,mergeStrat("overlap"),"minpoly");
    }

    setring rLex;
    list WMSimplified = imap(rSimplified,WMSimplified);
    matrix WSimplified = WMSimplified[1];
    intvec MSimplified = WMSimplified[2];


    // 4: reconstruct tropical variety of (un-)Simplified ideal
    // 4.1  construct W
    //        each row of W are the tropical polynomials in u
    //        evaluated at the same row of WSimplified
    matrix W[nrows(WSimplified)][n];
    for (int i=nrows(W); i>0; i--)
    {
      ideal xImageTropSubst = xImageTrop;
      for (int j=size(u); j>0; j--)
      {
        xImageTropSubst = subst(xImageTropSubst,u[j],WSimplified[i,j]);
      }
      W[i,1..n] = xImageTropSubst;
    }

    // 4.2  construct M and save both W and M in the global list spanning all triangular sets
    intvec M = MSimplified;
    triangularDecompositionWM[kTriang] = list(W,M);
  }


  // 5: merge W and M for all triangular sets
  setring rLex;
  list globalWM = triangularDecompositionWM[size(triangularDecomposition)];
  for (int i=size(triangularDecomposition)-1; i>0; i--)
  {
    globalWM = mergeMultisets(globalWM,triangularDecompositionWM[i]);
  }

  setring rOrigin;
  list globalWM = fetch(rLex,globalWM);
  return (globalWM);
}
example
{ "EXAMPLE:"; echo = 2;
  ring r = 0,(x,y,z,w),dp;
  number uniformizingParameter = 2;

  // Example 1: roots in the base field,
  //   triangular decomposition + elimpart will find all solutions
  //   no explicit tropical variety computation necessary
  ideal I1 =
    (x-1)*(x-2)*(x-4)*(x-6)*(x-8),
    y-2x,
    z-2y,
    w-2z;
  list TropI1 = tropicalVarietyZerodimensional(I1,uniformizingParameter);
  print(TropI1[1]);
  TropI1[2];

  // Example 2: roots not in the base field, but ideal in shape form
  //   triangular decomposition + elimpart will eliminate all but one variable
  //   no explicit tropical variety computation necessary
  ideal I2 =
    2+x+x2+x3+2x4,
    y-2x,
    z-2y,
    w-2z;
  list TropI2 = tropicalVarietyZerodimensional(I2,uniformizingParameter);
  print(TropI2[1]);
  TropI2[2];

  // Example 3: explicit tropical variety computation necessary
  ideal I3 =
    2+x+x2+x3+2x4,
    y-2x2+x+1,
    z-x2+2x+1,
    w-x2+x+2;
  list TropI3 = tropicalVarietyZerodimensional(I3,uniformizingParameter);
  print(TropI3[1]);
  TropI3[2];
}

proc computeUnmixedInitialIdeal(ideal uI, number uniformizingParameter, intvec w)
{
  // rather than computing the unmixed initial ideal straight up
  // it is often faster to compute an initial ideal over the coefficient field
  // with respect to the weight vector first (indep. of any valuation)
  def rOrigin = basering;
  int n = nvars(basering);

  intvec wPre = -onesVector(n);
  wPre[1] = 0;
  execute("ring rInitial = ("+charstr(rOrigin)+"),("+varstr(rOrigin)+"),(a(wPre),a(w),rp);");
  option(prot);
  ideal uI = fetch(rOrigin,uI);
  uI = groebner(uI);
  option(noprot);
  number uniformizingParameter = fetch(rOrigin,uniformizingParameter);

  option(infRedTail);
  uI = uniformizingParameter-var(1), simplify(reduce(uI,uniformizingParameter-t),2);
                        // terminates as valuation decreases
                        // if (absolute) degree increases
                        // uI is homogeneous in x and contains p-t
  option(noinfRedTail);
  ideal inI = initial(uI,w);
  export(rInitial);
  export(uI);
  export(uniformizingParameter);
  export(inI);
  return (rInitial);
}


static proc mergeRays(list A, list B)
{
  list AB;
}


/***
 * Given a reduced Groebner basis of an initial ideal
 * with respect to a weight on a codimension one tropical cone and the uniformizing parameter,
 * compute the link around the cone
 */
proc tropicalLink(ideal inIu, number uniformizingParameter)
{
  def rUnmixed = basering;

  // 1. inIu has a codimension one lineality space
  //    reduce to dimension one by removing it
  inIu = dissectLinealitySpace(inIu);

  // 2. reduce to multiple dimension zeroes
  //    by intersecting it with the sides of a box
  def rResidue = residueTropicalPolynomialData(inIu, uniformizingParameter);
  setring rResidue;

  ideal inIr = Ir;
  list rayGenerators;
  for (int sign=1; sign>=-1; sign = sign-2)
  {
    for (int i=nvars(basering); i>0; i--)
    {
      ideal inIcut = inIr,var(i)-uniformizingParameter^(sign);
      inIcut = satstd(inIcut);

      if (dim(inIcut)==-1)
      {
        // no tropical intersection points here
        i++;
        continue;
      }

      list WM = tropicalVarietyZerodimensional(inIcut,uniformizingParameter);
      list W = WM[1];
      rayGenerators = mergeRays(rayGenerators,primitive(W));
    }
  }

  return (rayGenerators);
}


// copied from groebnerCone.cc
proc groebnerConeFromIdeals(ideal I, ideal inI)
{
  int N = nvars(basering);
  int rInEq, rEq = 0, 0;
  int i,j;
  for (i = 1; i <= ncols(I); i++)
  {
    rInEq = rInEq + size(I[i]) - 1;
  }
  for (i = 1; i <= ncols(inI); i++)
  {
    rEq = rEq + size(inI[i]) - 1;
  }
  intmat inequalities[rInEq][N];
  intmat equalities[rEq][N];
  intvec leadexpv;
  int row = 0;
  for (i = 1; i <= ncols(I); i++)
  {
    leadexpv = leadexp(I[i]);
    for (j = 2; j <= size(I[i]); j++)
    {
      row++;
      inequalities[row,1..N] = leadexpv-leadexp(I[i][j]);
    }
  }
  row = 0;
  for (i = 1; i <= ncols(inI); i++)
  {
    leadexpv = leadexp(inI[i]);
    for (j = 2; j <= size(inI[i]); j++)
    {
      row++;
      equalities[row,1..N] = leadexpv-leadexp(inI[i][j]);
    }
  }
  return(canonicalizeCone(coneViaInequalities(inequalities, equalities)));
}

proc computeDecoratedGroebnerConeFromWeight(ideal uI, number uniformizingParameter, intvec w, list symmetryGroup)
{
  def rUnmixed = basering;

  def rSigma = computeUnmixedInitialIdeal(uI, uniformizingParameter, w);
  setring rSigma;
  cone CwI = groebnerConeFromIdeals(uI,inI);

  decoratedGroebnerCone sigma;
  sigma.polyhedralCone = CwI;
  sigma.orbitIdentifier = minimalRepresentative(uniquePoint(CwI),symmetryGroup);
  sigma.polynomialRing = rSigma;
  sigma.polynomialIdeal = uI;
  sigma.initialIdeal = inI;
  sigma.uniformizingParameter = uniformizingParameter;

  setring rUnmixed;
  return (sigma);
}

proc decoratedGroebnerConeFromIdeals(ideal I, ideal inI, list symmetryGroup)
{
  decoratedGroebnerCone sigma;
  sigma.polynomialRing = basering;
  sigma.polynomialIdeal = I;
  sigma.uniformizingParameter = uniformizingParameter;
  sigma.polyhedralCone = groebnerConeFromIdeals(I,inI);
  sigma.orbitIdentifier = minimalRepresentative(uniquePoint(sigma.polyhedralCone),symmetryGroup);
  return (sigma);
}

// In: M,N two bigintmats
// Out: 1, 0, -1 if M>N, M==N, M<N resp.
static proc bigintmatComparison(bigintmat M, bigintmat N)
{
  int r = nrows(M);
  int c = ncols(M);
  if (c>ncols(N) || r>nrows(N))
  {
    return (1);
  }
  if (c<ncols(N) || r<nrows(N))
  {
    return (-1);
  }

  int i,j;
  for (i=1; i<=r; i++)
  {
    for (j=1; j<=c; j++)
    {
      if (M[i,j] > N[i,j])
      {
        return (1);
      }
      if (M[i,j] < N[i,j])
      {
        return (-1);
      }
    }
  }
  return (0);
}

// In: list of bigintmats, optional second list
// Out: list of bigintmats, sorted from small to large
//        + optional second list changed the same
static proc listOfBigintmatSort(list L, #)
{
  int twoInputLists = 0;
  if (typeof(#)=="list")
  {
    twoInputLists = 1;
  }

  int b;
  for (int i=1; i<size(L); i++)
  {
    // Compare i-th entry to the next
    b = bigintmatComparison(L[i],L[i+1]);
    if (b>0)
    {
      // if bigger: swap and reset i
      def cache = L[i+1];
      L[i+1] = L[i];
      L[i] = cache;
      kill cache;

      if (twoInputLists)
      {
        def cache = #[i+1];
        #[i+1] = #[i];
        #[i] = cache;
        kill cache;
      }

      i=0;
    }
    if (b==0)
    {
      // if equal: delete and decrement i
      L = delete(L,i);

      if (twoInputLists)
      {
        # = delete(#,i);
      }

      i--;
    }
  }

  if (twoInputLists)
  {
    return (L,#);
  }
  return (L);
}

// In: L,K two sorted lists of bigintmats
// Out: list, containing the positions after which the entries of K are to be inserted in L
//        or -1 if an entry of K already exists in L
static proc findInsertionPoints(alias list L, list K, #)
{
  int threeInputLists = 0;
  if (typeof(#)=="list")
  {
    threeInputLists = 1;
  }

  list insertionIndices;
  int b;
  for (int i,j=1,1; i<=size(L) && j<=size(K); i++)
  {
    // Compare i-th entry of L to j-th entry of K
    b = bigintmatComparison(L[i],K[j]);
    if (b>0)
    {
      // if bigger, set place to insert j-th entry of K to i-1
      // increment j and decrement i
      insertionIndices[j] = i-1;
      j++;
      i--;
    }
    if (b==0)
    {
      // if equal, delete j-th entry of K
      // decrement i
      K = delete(K,j);
      i--;

      if (threeInputLists)
      {
        # = delete(#,j);
      }
    }
  }
  // Fill up remaining insertion points
  for (; j<=size(K); j++)
  {
    insertionIndices[j] = size(L);
  }

  if (threeInputLists)
  {
    return (insertionIndices,K,#);
  }
  return (insertionIndices,K)
}


static proc bigintmatToListOfBigintmats(alias bigintmat uniquePointsOfFacets)
{
  list L;
  int k = nrows(uniquePointsOfFacets);
  int n = ncols(uniquePointsOfFacets);
  bigintmat uniquePointOfFacet[1][n];
  for (int i=1; i<=k; i++)
  {
    uniquePointOfFacet[1,1..n] = uniquePointsOfFacets[i,1..n];
    L[i] = uniquePointOfFacet;
  }
  return (L);
}


static proc bigintmatToIntvec(bigintmat uniquePointBigintmat)
{
  return (intvec(int(uniquePointBigintmat[1,1..ncols(uniquePointBigintmat)])));
}


/***
 * Given a reduced Groebner basis and a weight on a facet of the tropical variety, does:
 *   1) Computes the tropical link around the facet.
 *   2) Computes the adjacent decorated Groebner cone in the tropical variety, i.e.
 *       - constructs a ring equipped with the proper adjacent ordering
 *       - does a Groebner flip to compute a reduced Groebner basis in that ordering
 *       - constructs the adjacent Groebner cone
 *       - computes the sum of all rays of the Groebner cone
 * Returns a list of lists, one for each ray of the tropical link, containing:
 *   - (def) a ring equipped with the adjacent ordering containing an ideal stdI
 *   - (cone) an adjacent maximal tropical Groebner cone
 *   - (bigintmat) the signature of the adjacent Groebner cone
 **/
proc tropicalNeighboursLink(ideal I, bigintmat interiorFacetPoint, alias list symmetryGroup)
{
  def origin = basering;
  list TIw;
  int i, j, k;
  ideal inIsGB, inIsGBNF;

  // 1) Compute the tropical link around the facet
  ideal inI = initial(I,interiorFacetPoint);
  list tropicalLink = tropicalLinkNewton(inI);

  // 2) For each tropical link
  intvec wOnes;
  for (i=1; i<=nvars(basering); i++)
  {
    wOnes[i]=1;
  }
  matrix outerNormalVectorMatrix;
  intvec outerNormalVector;
  for (i=1; i<=size(tropicalLink); i++)
  {
    outerNormalVectorMatrix = tropicalLink[i];
    outerNormalVector = scaleAndCastToIntvec(outerNormalVectorMatrix);

    execute("ring adjRing("+string(i)+") = ("+charstr(origin)+"),("+varstr(origin)+"),(a(wOnes),a(bigintmatToIntvec(interiorFacetPoint)),a(outerNormalVector),lp);");
    ideal inIsGB = std(fetch(origin,inI));

    setring origin;
    inIsGB = fetch(adjRing(i), inIsGB);
    inIsGBNF = NF(inIsGB, I);

    setring adjRing(i);
    ideal inIsGBNF = fetch(origin,inIsGBNF);
    ideal IsGBnonred;
    k = ncols(inIsGB);
    for (j = 1; j <= k; j++)
    {
      IsGBnonred[j] = inIsGB[j] - inIsGBNF[j];
    }

    ideal stdI = interred(IsGBnonred);
    attrib(stdI, "isSB", 1);
    ideal inI = initial(stdI,interiorFacetPoint,outerNormalVector);
    number uniformizingParameter = fetch(origin,uniformizingParameter);

    decoratedGroebnerCone neighbourCone;
    neighbourCone.polyhedralCone = groebnerConeFromIdeals(stdI, inI);
    neighbourCone.orbitIdentifier = minimalRepresentative(uniquePoint(neighbourCone.polyhedralCone),symmetryGroup);
    neighbourCone.polynomialRing = adjRing(i);
    neighbourCone.polynomialIdeal = stdI;
    neighbourCone.uniformizingParameter = uniformizingParameter;
    TIw[i] = neighbourCone;
    kill neighbourCone;
    setring origin;
  }

  return (TIw);
}

proc tropicalNeighboursCone(decoratedGroebnerCone coneInWorkingList, list knownCones, list knownLinks, list symmetryGroup)
{
  // 0. Parse data in coneInWorkingList
  cone C = coneInWorkingList.polyhedralCone;
  def originTropicalTraversalStep = coneInWorkingList.polynomialRing;
  setring originTropicalTraversalStep;
  ideal stdI = coneInWorkingList.polynomialIdeal;
  number uniformizingParameter = coneInWorkingList.uniformizingParameter;
  export(uniformizingParameter);

  // 1.a. Compute a unique point in each facet and their signatures
  list facetPoints = bigintmatToListOfBigintmats(uniquePointsOfFacets(C));
  list facetSignatures;
  for (int i=1; i<=size(facetPoints); i++)
  {
    facetSignatures[i] = minimalRepresentative(facetPoints[i],symmetryGroup);
  }

  // 1.b. Sort facetSignatures and change facetPoints accordingly
  facetSignatures,facetPoints = listOfBigintmatSort(facetSignatures,facetPoints);

  // 1.c. Find the insertion points of the signatures
  //        and delete those which are redundant, as well as the points
  list facetSignaturesInsertionPoints;
  facetSignaturesInsertionPoints,facetSignatures,facetPoints = findInsertionPoints(knownLinks,facetSignatures,facetPoints);

  // 2. Compute tropical neighbours for each remaining facet
  list neighbouringCones;
  for (i=1; i<=size(facetPoints); i++)
  {
    neighbouringCones = neighbouringCones + tropicalNeighboursLink(stdI,facetPoints[i],symmetryGroup);
  }

  // 3.a Read out newCones, sort them and neighouringCones accordingly.
  list newCones;
  for (i=1; i<=size(neighbouringCones); i++)
  {
    newCones[i] = neighbouringCones[i].orbitIdentifier;
  }
  newCones,neighbouringCones = listOfBigintmatSort(newCones,neighbouringCones);

  // 3.b. Find the insertion points of newcones and delete those which are redundant,
  //        as well as their corresponding neighbouringCones
  list newConesInsertionPoints;
  newConesInsertionPoints,newCones,neighbouringCones = findInsertionPoints(knownCones,newCones,neighbouringCones);

  return(list(neighbouringCones,newCones,newConesInsertionPoints,facetSignatures,facetSignaturesInsertionPoints));
}

proc naRandomNumber(number uniformizingParameter, int cval, list #)
"USAGE:  naRandomNumber(number uniformizingParameter, int cval[, int csize, int clength, int cspread]);
RETURN:  a randomized number with a given valuation of the form
           c_1 p^{v_1} + ... + c_k p^{v_k}, where
         - p = uniformizingParameter
         - k = clength
         - v_1 = cval
         _ v_i = v_{i-1} + random(0,cspread)
         - c_i = r_i/valuation(r_i,p) with r_i = random(0,csize)
NOTE:    defaults:
         - csize = 9999
         - clength = 3
         - cspread = 9
         rule of thumb:
         - for padic: more length, less spread (as default)
         - for Puiseux: less length, more spread
"
{
  int csize = 9999;
  if (size(#)>0)
  {
    csize = #[1];
  }
  int clength = 3;
  if (size(#)>1)
  {
    clength = #[2];
  }
  int cspread = 9;
  if (size(#)>2)
  {
    cspread = #[3];
  }

  int v = cval;
  number c = random(1,csize);
  c = c/uniformizingParameter^valuation(c,uniformizingParameter);
  number C = c*uniformizingParameter^v;
  for (int i=1; i<clength; i++)
  {
    v = v+random(1,cspread);
    number c = random(1,csize);
    c = c/uniformizingParameter^valuation(c,uniformizingParameter);
    C = C + c*uniformizingParameter^v;
  }

  return (C);
}
example
{ "EXAMPLE for testing purposes"; echo=2;
  ring r = 0,x,dp;
  number uniformizingParameter = 2;
  naRandomNumber(uniformizingParameter, 0);
  naRandomNumber(uniformizingParameter, 0, 999999, 2, 33);
  naRandomNumber(uniformizingParameter, 0, 999999, 5, 3);

  ring s = (0,t),x,dp;
  number uniformizingParameter = t;
  naRandomNumber(uniformizingParameter, 0);
  naRandomNumber(uniformizingParameter, 0, 999999, 2, 33);
  naRandomNumber(uniformizingParameter, 0, 999999, 5, 3);
}

static proc naRandomLinearForm(number uniformizingParameter, int b, list #)
{
  poly f = naRandomNumber(uniformizingParameter, random(0,b), #);
  for (int i=nvars(basering); i>0; i--)
  {
    f = f + naRandomNumber(uniformizingParameter, random(0,b), #) * var(i);
  }
  return (f);
}

static proc naRandomLinearSpace(int cd, number uniformizingParameter, int b, list #)
{
  ideal L;
  for (int i=cd; i>0; i--)
  {
    L[i] = naRandomLinearForm(uniformizingParameter,b,#);
  }
  return (groebner(L));
}
example
{ "EXAMPLE for testing purposes"; echo=2;
  int n = 5;

  ring r = 0,(x1,x2,x3,x4,x5),dp;
  number uniformizingParameter = 2;
  ideal L1 = naRandomLinearSpace(1,uniformizingParameter, 99);
  n - dim(L1);
  ideal L2 = naRandomLinearSpace(2,uniformizingParameter, 99);
  n - dim(L2);
  ideal L3 = naRandomLinearSpace(3,uniformizingParameter, 99);
  n - dim(L3);

  ring s = (0,t),(x1,x2,x3,x4,x5),dp;
  number uniformizingParameter = t;
  ideal L1 = naRandomLinearSpace(1,uniformizingParameter, 99);
  n - dim(L1);
  ideal L2 = naRandomLinearSpace(2,uniformizingParameter, 99);
  n - dim(L2);
  ideal L3 = naRandomLinearSpace(3,uniformizingParameter, 99);
  n - dim(L3);
}

static proc dissectLinealitySpace(ideal stdI)
"USAGE:  dissectLinealitySpace(ideal stdI);
ASSUME:  stdI reduced Groebner basis
RETURN:  ideal stdIL, such that Trop(stdIL) = Trop(stdI) \cap H
           for a linear space H generated by unit vectors and
           orthogonal to the the lineality space of Trop(stdI)
"
{
  cone C0 = homogeneitySpace(stdI);
  matrix H = gauss_nf(intmat(generatorsOfLinealitySpace(C0)));
  intvec p = pivotIndices(H);

  ideal L;
  for (int i=1; i<=nvars(basering); i++)
  {
    if (p[i]==1)
    {
      L[size(L)+1] = var(i)-1;
    }
  }

  return (groebner(stdI+L));
}


static proc homogenizeMatrix(matrix CMatrix)
"USAGE:  homogenizeMatrix(matrix CMatrix);
ASSUME:  CMatrix is a matrix of rational numbers
RETURN:  intmat CIntmat, each row of CInmat is a row of CMatrix
           in homogeneous coordinates
"
{
  int r = nrows(CMatrix);
  int c = ncols(CMatrix);

  intmat CIntmat[r][c+1];
  int denominatorLCM;
  for (int i=1; i<=r; i++)
  {
    // multiply each row with the lcm of all denominators
    denominatorLCM = int(denominator(number(CMatrix[i,1])));
    for (int j=2; j<=c; j++)
    {
      denominatorLCM = lcm(denominatorLCM,int(denominator(number(CMatrix[i,j]))));
    }
    CMatrix[i,1..c] = CMatrix[i,1..c]*denominatorLCM;

    CIntmat[i,1] = -denominatorLCM;
    CIntmat[i,2..c+1] = int(CMatrix[i,1..c]);
  }

  return(CIntmat);
}

proc tropicalPoints(ideal I, number uniformizingParameter, list #)
"USAGE:  tropicalPoints(ideal I, number uniformizingParameter[, int b]);
RETURN:  a list of points on Trop(I)
NOTE:    intersects V(I) with a random affine linear space H complementary dimension
           with Trop(H) orthogonal to the lineality space of Trop(I) and
           generated by linear forms whose coefficients have valuation between 0 and b (default: b=32).
           Returns the tropicalization of the resulting zero-dimensional ideal
EXAMPLE: example tropicalPoints; shows an example
"
{
  int b = 32;
  if (size(#) > 0)
  {
    b = #[1];
  }

  // 1: reduce to dimension 0
  def rOrigin = basering;
  int n = nvars(basering);
  I = groebner(I);

  // 1.1: dissect lineality space
  ideal IL = dissectLinealitySpace(I);
  int dIL = dim(IL);

  // 1.2: intersect with affine space of complimentary dimension
  ideal IL0 = groebner(IL+naRandomLinearSpace(dIL,uniformizingParameter,99),0);
  int dIL0 = dim(IL0);
  while (dIL0>0)
  {
    dbprint("WARNING: tropicalPoints: encountered degenerate affine linear space");
    IL0 = groebner(IL+naRandomLinearSpace(dIL,uniformizingParameter,99),0);
    dI0 = dim(IL0);
  }

  // 2: compute zerodimensional tropical variety
  list WM = tropicalVarietyZerodimensional(IL0,uniformizingParameter);
  return(list(WM[1],WM[2]));
}

proc mixCharacteristics(ideal uI, number uniformizingParameter, list #)
"USAGE:  mixCharacteristics(ideal uI, number uniformizingParameter[, intvec w, intvec u]);
RETURN:  a ring with mixed characteristics and monomial ordering:
         - dp, if u and v unspecified
         - a(1,...,1), a(u), rp, if only u specified
         - a(1,...,1), a(u), a(v), rp, if u and v specified
         inside the ring, an ideal mI and a number uniformizingParameter are defined
EXAMPLE: example tropicalPoints; shows an example
"
{
  // 0: parse optional parameters, save basering
  //    and construct its ringlist
  intvec u;
  if (size(#)>0)
  {
    u = #[1];
  }
  intvec v;
  if (size(#)>1)
  {
    u = #[2];
  }

  def rOrigin = basering;
  int n = nvars(basering);
  list rlOrigin = ringlist(basering);

  // 1: create variable string for the mixed ring
  list varList = rlOrigin[2];
  string varString = "("+string(list(varList[2..n]))+")";

  // 2: create ordering string for the mixed ring
  intvec allOnes = onesVector(n-1);
  string ordString = "(a(allOnes)";
  if (size(u)>1)
  {
    ordString = ortString+",a(u)";
  }
  if (size(v)>1)
  {
    ordString = ortString+",a(v)";
  }
  ordString = ordString+",rp)";

  // 3: create char string for the mixed ring
  string charString;
  if (pardeg(uniformizingParameter)>0)
  {
    ERROR("mixCharacteristics: Puiseux case not implemented yet"); // todo
  }
  else
  {
    charString = "(0)";
  }

  // 4: create mixed ring and export data to be saved
  execute("ring rMixed = "+charString+","+varString+","+ordString+";");

  number uniformizingParameter = fetch(rOrigin,uniformizingParameter);
  map phiMixed = rOrigin,uniformizingParameter,maxideal(1);
  ideal mI = phiMixed(uI);
  export(mI);
  export(uniformizingParameter);
  return (rMixed);
}

proc tropicalStartingCones(ideal uI, number uniformizingParameter, list #)
"USAGE:  tropicalStartingCones(ideal sI, number uniformizingParameter[, list symmetryGroup]);
ASSUME:  uI unmixed
RETURN:  a list of maximal decorated Groebner cones on Trop(I)
NOTE:    Repeatedly calls tropicalPoints until at least one maximal cone is found.
         Returns all maximal cones found in that iteration
EXAMPLE: example tropicalStartingCones; shows an example
TODO:    One can reuse the initial ideals of the lower-dimensional points
         to compute maximal-dimensional points.
         However, the initial ideals will most likely be over finite characteristics,
         and Singular does not support working with rational data
         unless the rational numbers are a subfield of the coefficient field.
"
{
  list symmetryGroup;
  if (size(#) > 0)
  {
    symmetryGroup = #;
  }

  def rOrigin = basering;
  def rMixed = mixCharacteristics(uI, uniformizingParameter);
  setring rMixed;
  mI = groebner(mI);
  int dmI = dim(mI);

  list startingCones;
  for (int iterationNumber=1; size(startingCones)==0; iterationNumber++)
  {
    // 1. compute a random section of tropical points
    //    with increasing bounds
    setring rMixed;
    list WM = tropicalPoints(mI,uniformizingParameter,32+6*iterationNumber);
    intmat W = homogenizeMatrix(WM[1]);

    // 2. compute the Groebner cone around each tropical point
    setring rOrigin;
    string command = "computeDecoratedGroebnerConeFromWeight";
    list arguments;
    for (int i=nrows(W); i>0; i--)
    {
      arguments[i] = list(uI,uniformizingParameter,intvec(W[i,1..ncols(W)]),symmetryGroup);
    }
    list out = fakeParallelWaitAll(command,arguments);

    // 3. filter out those of maximal dimension
    for (int i=size(out); i>0; i--)
    {
      decoratedGroebnerCone sigma = out[i];
      int dsigma = dimension(sigma.polyhedralCone);
      if (dsigma > dmI+1)
      {
        ~;
        ERROR("tropicalStartingCones: encountered tropical polyhedra of too high dimension");
      }
      if (dsigma==dmI+1)
      {
        startingCones[size(startingCones)+1] = sigma;
      }
    }
  }
  return (startingCones);
}

proc fakeParallelWaitAll(string command, list args)
{
  list out;
  for (int i=1; i<=size(args); i++)
  {
    execute("out[i] = "+command+"(args[i][1],args[i][2],args[i][3],args[i][4]);");
  }
  return (out);
}

static proc isIthInsertionPointMinimal(alias list newConesInsertionPoints, int i, int minimalInsertionPoint)
{
  if (size(newConesInsertionPoints[i])>0)
  {
    if (newConesInsertionPoints[i][1]==minimalInsertionPoint)
    {
      return (1);
    }
  }
  return (0);
}

static proc unmixTropicalVarietyInput(ideal I, number uniformizingParameter, list symmetryGroup)
{
  def rOrigin = basering;

  if (pardeg(uniformizingParameter)>0)
  { // unmixed characteristics case
    string charStr = "("+string(char(rOrigin))+")";
    string varStr = "("+parstr(1)+","+varstr(basering)+")";

    execute("ring rUnmixed ="+charStr+","+varStr+",dp;");
    number uniformizingParameter = fetch(r,uniformizingParameter);
    ideal Iu = uniformizingParameter-var(1),imap(r,I);

    export(rUnmixed);
    export(Iu);
    export(uniformizingParameter);
    return (rUnmixed);
  }

  if (prime(int(uniformizingParameter))==int(uniformizingParameter)) // prime returns smallest prime >= p
  {
    string charStr = "(integer)";
    for (int i=1; i<=nvars(rOrigin); i++)
    {
      if (varstr(i)=="t")
      {
        ERROR("unmixTropicalVarietyInput: variable name t reserved for uniformizing variable");
      }
    }
    string varStr = "(t,"+varstr(basering)+")";

    execute("ring rUnmixed ="+charStr+","+varStr+",dp;");
    number uniformizingParameter = fetch(r,uniformizingParameter);
    ideal uI = uniformizingParameter-var(1),imap(r,I);

    export(rUnmixed);
    export(uI);
    export(uniformizingParameter);
    return (rUnmixed);
  }

  ERROR("unmixTropicalVarietyInput: invalid uniformizingParameter");
}

// computes the tropical variety of a homogeneous prime ideal
proc tropicalVarietyCore(ideal I, number uniformizingParameter, list symmetryGroup)
{
  // 0. Save original ring and read in symmetry group
  def rMixed = basering;

  // 1. Unmix the ideal and compute the starting cone
  def rUnmixed = unmixTropicalVarietyInput(I,uniformizingParameter,symmetryGroup);
  setring rUnmixed;
  list startingCones = tropicalStartingCones(uI,uniformizingParameter,symmetryGroup);

  // 2.0 Initialize traversal data:
  //    - finishedList: a list of decoratedGroebnerCones, for whom all neighbours are known
  //    - workingList: a list of decoratedGroebnerCones, for whom not all neighbours are known
  //    - knownCones: a list of signatures of maximal Groebner cones in the tropical variety
  //        this exists to efficiently check whether a newly computed cone is already known
  //    - knownLinks: a list of signatures of codimension-one Groebner cones
  //        in the tropical variety whose adjacent maximal cones are guaranteed to be known
  //        this exists to avoid costly redundant computations
  list finishedList;
  list workingList = startingCones;
  list knownCones = startingCone.orbitIdentifier;
  list knownLinks;

  string command = "tropicalNeighboursCone";
  list args;
  list out;
  int maximalLoad = getcores();
  int currentLoad;

  int i,j,b;
  list newNeighbours;
  list newCones;
  list newConesInsertionPoints;
  list newLinks;
  list newLinksInsertionPoints;

  list minimalNewNeighbours;
  list minimalNewCones;
  list minimalNewLinks;
  int minimalNewConeInsertionPoint;
  int minimalNewLinkInsertionPoint;
  int newConesRemaining;
  int newLinksRemaining;

  while (size(workingList)>0)
  {
    // 2.a. Prepare up to maximalLaod inputs for tropicalNeighboursCone,
    //        add them to the finished list and delete them from the working list
    currentLoad = min(maximalLoad,size(workingList));
    args = list();
    for (i=1; i<=currentLoad; i++)
    {
      args[i] = list(workingList[1],knownCones,knownLinks,symmetryGroup);
      finishedList[size(finishedList)+1] = workingList[1];
      workingList = delete(workingList,1);
    }

    // 2.b. Run currentLoad parallel tropicalNeighboursCone
    out = parallelWaitAll(command,args);

    // 2.c. Parse currentLoad outputs of tropicalNeighboursCone,
    //        and count the total number of newCones and newLinks
    newNeighbours = list();
    newCones = list();
    newConesInsertionPoints = list();
    newLinks = list();
    newLinksInsertionPoints = list();
    newConesRemaining = 0;
    newLinksRemaining = 0;
    for (i=1; i<=currentLoad; i++)
    {
      newNeighbours[i] = out[i][1];
      newCones[i] = out[i][2];
      newConesInsertionPoints[i] = out[i][3];
      newLinks[i] = out[i][4];
      newLinksInsertionPoints[i] = out[i][5];
      newConesRemaining = newConesRemaining + size(newCones[i]);
      newLinksRemaining = newLinksRemaining + size(newLinks[i]);
    }

    // 3. Bookkeeping: merging all newCones
    while (newConesRemaining>0)
    {
      // 3.a. Find minimal insertion point amongst the remaining cones
      minimalNewNeighbours = list();
      minimalNewCones = list();
      minimalNewConeInsertionPoint = size(knownCones)+1;
      for (i=1; i<=currentLoad; i++)
      {
        if (size(newConesInsertionPoints[i])>0)
        {
          minimalNewConeInsertionPoint = min(minimalNewConeInsertionPoint,newConesInsertionPoints[i][1]);
        }
      }
      // 3.b. Gather all minimal cones to be inserted in that position
      for (i=1; i<=currentLoad; i++)
      {
        while(isIthInsertionPointMinimal(newConesInsertionPoints,i,minimalNewConeInsertionPoint))
        {
          minimalNewNeighbours[size(minimalNewNeighbours)+1] = newNeighbours[i][1];
          minimalNewCones[size(minimalNewCones)+1] = newCones[i][1];
          newNeighbours[i] = delete(newNeighbours[i],1);
          newCones[i] = delete(newCones[i],1);
          newConesInsertionPoints[i] = delete(newConesInsertionPoints[i],1);
          newConesRemaining--;
        }
      }
      // 3.c. Sort the gathered cones, neighboring cones accordingly.
      minimalNewCones,minimalNewNeighbours = listOfBigintmatSort(minimalNewCones,minimalNewNeighbours);

      // 3.d. Insert sorted cones into knownCones and workingList
      for (i=1; i<=size(minimalNewCones); i++)
      {
        workingList[size(workingList)+1] = minimalNewNeighbours[i];
        knownCones = insert(knownCones,minimalNewCones[i],minimalNewConeInsertionPoint);
        minimalNewConeInsertionPoint++;
      }
      // 3.e. Increment remaining insertion points by the amount of cones inserted
      for (i=1; i<=currentLoad; i++)
      {
        for (j=1; j<=size(newConesInsertionPoints[i]); j++)
        {
          newConesInsertionPoints[i][j] = newConesInsertionPoints[i][j] + size(minimalNewCones);
        }
      }
    }

    // 4. Bookkeeping B: merging all newLinks
    while (newLinksRemaining>0)
    {
      // 4.a. Find minimal insertion point amongst the remaining links
      minimalNewLinks = list();
      minimalNewLinkInsertionPoint = size(knownLinks)+1;
      for (i=1; i<=currentLoad; i++)
      {
        if (size(newLinksInsertionPoints[i])>0)
        {
          minimalNewLinkInsertionPoint = min(minimalNewLinkInsertionPoint,newLinksInsertionPoints[i][1]);
        }
      }
      // 4.b. Gather all minimal links to be inserted in that position
      for (i=1; i<=currentLoad; i++)
      {
        while(isIthInsertionPointMinimal(newLinksInsertionPoints,i,minimalNewLinkInsertionPoint))
        {
          minimalNewLinks[size(minimalNewLinks)+1] = newLinks[i][1];
          newLinks[i] = delete(newLinks[i],1);
          newLinksInsertionPoints[i] = delete(newLinksInsertionPoints[i],1);
          newLinksRemaining--;
        }
      }
      // 4.c. Sort the gathered links and remove duplicates
      minimalNewLinks = listOfBigintmatSort(minimalNewLinks);

      // 4.d. Insert sorted links into knownLinks
      for (i=1; i<=size(minimalNewLinks); i++)
      {
        knownLinks = insert(knownLinks,minimalNewLinks[i],minimalNewLinkInsertionPoint);
        minimalNewLinkInsertionPoint++;
      }
      // 4.e. Increment remaining insertion points by the amount of links inserted
      for (i=1; i<=currentLoad; i++)
      {
        for (j=1; j<=size(newLinksInsertionPoints[i]); j++)
        {
          newLinksInsertionPoints[i][j] = newLinksInsertionPoints[i][j] + size(minimalNewLinks);
        }
      }
    }

    dbprint("finished cones: "+string(size(finishedList))
          +", working cones: "+string(size(workingList)));
  }
  return (finishedList);
}

/*
 * PROCEDURES DOING THE ABOVE AND WRITING OUTPUT INTO FILES
 */
static proc writeNecessarySSIData(def S, cone C, string filename)
{
  setring S;
  link ssiLink = "ssi:w "+filename;
  write(ssiLink, stdI);
  write(ssiLink, C);
  close(ssiLink);
}

proc getInteriourPointsSSI(string filename, alias list symmetryGroup)
{
  link ssiLink = "ssi:r "+filename;
  def I = read(ssiLink);
  def C = read(ssiLink);
  close(ssiLink);

  bigintmat interiorPoints = relativeInteriorPointsOfFacets(C);
  int rows = nrows(interiorPoints);
  int cols = ncols(interiorPoints);
  bigintmat point[1][cols];
  list tropicalLinks;
  list tropicalLinksModSymmetry;
  int i, j;
  for (i = 1; i <= rows; i++)
  {
    // extract submatrix
    for (j = 1; j <= cols; j++)
    {
      point[1,j] = interiorPoints[i,j];
    }
    tropicalLinks[i] = bigintmatToIntvec(point, 1);
    tropicalLinksModSymmetry[i] = bigintmatToIntvec
      ( minimalRepresentative(point, symmetryGroup)
      , 1
      );
  }
  return(tropicalLinks, tropicalLinksModSymmetry);
}

proc traverseInteriourPointSSI(intvec interiourPoint, string filename, alias list symmetryGroup, alias string prefix)
{
  link ssiLink = "ssi:r "+filename;
  def I = read(ssiLink);
  // cone is irrelevant
  close(ssiLink);
  setUniformizingParameter(par(1));

  list neighbourCones = tropicalNeighboursLink(I, interiourPoint);
  list points;
  for (int i = 1; i <= size(neighbourCones); i++)
  {
    writeNecessarySSIData
      ( neighbourCones[i][1]
      , neighbourCones[i][2]
      , prefix + "/" + string(i-1)
      );
    points[i] = bigintmatToIntvec
      ( minimalRepresentative(neighbourCones[i][3], symmetryGroup)
      , 1
      );
  }
  return(points);
}

// compute a starting cone
proc tropicalStartingConeSSI(ideal I, alias list symmetryGroup, alias string outFile)
{
  list gCone = tropicalStartingCone(I);
  def initRing = gCone[1];
  intvec uniquePoint = bigintmatToIntvec
    ( minimalRepresentative(gCone[3], symmetryGroup)
    , 1
    );

  writeNecessarySSIData(initRing, gCone[2], outFile);
  return(uniquePoint);
}

// proc saturateWithRespectToVariable(ideal I, int k)
// {
//   ASSUME(1,k>=1);
//   ASSUME(1,k<=nvars(basering));

//   def origin = basering;
//   int n = nvars(basering);
//   intvec weightVector = ringlist(origin)[3][1][2];

//   string newVars;
//   for (int i=1; i<k; i++)
//   {
//     newVars = newVars+string(var(i))+",";
//   }
//   for (i=k+1; i<=n; i++)
//   {
//     newVars = newVars+string(var(i))+",";
//   }
//   newVars = newVars+string(var(k));
//   execute("ring ringForSaturation = ("+charstr(origin)+"),("+newVars+"),dp;");

//   ideal I = satstd(imap(origin,I));
//   if (I==-1)
//   {
//     return (-1);
//   }
//   I = simplify(I,2+4+32);

//   setring origin;
//   I = imap(ringForSaturation,I);
//   return (I);
// }

// proc stepwiseSaturation(ideal I)
// {
//   if (I!=1)
//   {
//     list variablesToBeSaturated;
//     int l = nvars(basering);
//     for (int i=1; i<=l; i++)
//     { variablesToBeSaturated[i]=l-i+1; }

//     while (size(variablesToBeSaturated)>0)
//     {
//       dbprint("variablesToBeSaturated: "+string(variablesToBeSaturated));
//       I = saturateWithRespectToVariable(I,variablesToBeSaturated[1]);
//       variablesToBeSaturated = delete(variablesToBeSaturated,1);
//       if ((I==1) || (I==-1))
//       {
//         break;
//       }
//     }
//   }

//   return (I);
// }


// proc checkForContainmentInTropicalVariety(ideal I, intvec w, int charInt)
// {
//   def origin = basering;
//   intvec wOne = oneVector(nvars(origin));
//   execute("ring rInitialIdeal = ("+string(charInt)+"),("+varstr(origin)+"),(a(wOne),wp(w));");

//   ideal I = imap(origin,I);
//   int tinI = timer;
//   option(redSB);
//   ideal stdI = satstd(I);
//   attrib(stdI,"isSB",1);
//   ideal inI = initial(stdI,w);
//   tinI = timer-tinI;
//   dbprint("time used computing initial ideal: "+string(tinI));

//   int tsat = timer;
//   ideal satinI = stepwiseSaturation(inI);
//   tsat = timer-tsat;
//   dbprint("time used computing saturation: "+string(tsat));


//   export(I);
//   export(stdI);
//   export(inI);
//   export(satinI);
//   return (rInitialIdeal);
// }
